package mutex;
import dist.*;
public class DinMutex extends dist.Process implements Lock {
    private static final int thinking = 0, hungry = 1, eating = 2;
    Boolean fork[] = null,  dirty[] = null, request[] = null;
    public int myState = thinking;
    public DinMutex(Linker initComm) {
        super(initComm);
        fork = new Boolean[N]; dirty = new Boolean[N];
        request = new Boolean[N];
        for (int i : comm.neighbors) {
            if (myId > i) {
                fork[i] = false; request[i] = true;
            } else { fork[i] = true; request[i] = false; }
            dirty[i] = true;
        }
    }
    public synchronized void requestCS() {
        myState = hungry;
        if (haveForks()) myState = eating;
        else
            for (int i: comm.neighbors)
                if (request[i] && !fork[i]) 
                    sendBool(i, "Request", request[i]); 
        while (myState != eating) myWait();
    }
    public synchronized void releaseCS() {
        myState = thinking;
        for (int i: comm.neighbors){
            dirty[i] = true;
            if (request[i]) sendBool(i, "Fork", fork[i]); 
        }
    }
    boolean haveForks() {
        for (int i: comm.neighbors)
            if (!fork[i]) return false;
        return true;
    }
    void sendBool(int dest, String tag, Boolean b) {
	sendMsg(dest, tag);
	b = false;
    }
    public synchronized void handleMsg(Msg m, int src, String tag) {
        if (tag.equals("Request")) {
            request[src] = true;
            if ((myState != eating) && fork[src] && dirty[src]) {
                sendBool(src, "Fork", fork[src]);
                if (myState == hungry)
                    sendBool(src, "Request", request[src]);
            }
        } else if (tag.equals("Fork")) {
            fork[src] = true; dirty[src] = false;
            if (haveForks()) 
                myState = eating; 
        }
    }
}
